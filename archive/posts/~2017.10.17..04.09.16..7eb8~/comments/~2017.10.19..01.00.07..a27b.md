## `~rovnys-ricfer`
~littel Thank you for writing this up! It's very cool, and I applaud your use of descriptive function names and thorough inline documentation.

Using a door for container arms doesn't mean we have to store a core. Only if an arm produces `.` would we need to store a core. Look at how, for example, `++in` arms work, for sets. Most of them cast their product to `^+ a`, where `a/(tree)` is the sample of the `|_`. None of them produce a core.

The idea of the `%~` rune is to allow you to wrap a core around a piece of data and then fire one of the arms in that core. It's a straight nock 9 call. One of the big differences between hoon and other functional programming languages is that hoon and nock provide the capability of bundling code and data together, and this is a convenient way to structure many types of code. I like to think of hoon code as consisting mostly of functional state machines, sort of like stateful objects where each of their previous states is still available for use. A door is a way to take a piece of data, wrap a state machine with a bunch of functions around the data, then crank the state machine until a new version of the data pops out as the product. Generally, any of the arms of the `|_` core that are intended to be fired externally (not just by another arm in the core) should produce some piece of data, not the core itself. There are some exceptions to this, such as parser combinators, since those are intended to produce gates, but the principle should hold for all the basic hoon datatypes.

As for four-letter names, I don't like forcing all the standard library arms to be four letters. I agree with ~winter-paches that using unusual names for standard things makes things harder, and I don't see the benefit. Some concepts in urbit are somewhat different from their terran counterparts, in which case it's a good idea to give them new names to prevent people from assuming they work exactly the same as what they're used to. For functions on lists, however, there's nothing new or misleading about using more standard names. As ~littel told me once, Urbit should spend its weirdness points wisely.

I think it would be great to namespace the arms in the standard library. It really helps for understanding a piece of code. Instead of wondering whether `zing` is some arm in the current file, in zuse, or in some obscure corner of the standard library, if you see `zing:ls` you can immediately say "ah, it's doing some list operation" and know where to look it up. Now that there's the `=,` rune for pouring a namespace into our namespace, if someone wants to use the arms without `:ls` everywhere, they can just `=,` it, so there's very little downside in my opinion. Namespacing might help keep the names shorter, too, which would be good.

Zooming out a little, ~sorreg and ~pittyp have convinced me we should avoid adding arms to the standard library that don't provide more functionality than an equivalent rune. The `++is-null` arm is an example of this: we could just use `?~` instead. This is related to the orientation that hoon should stay concrete as much as possible. We should not attempt to provide abstractions for our datatypes that completely obviate the need to understand their tree layout or their internals. That might be useful if, say, we thought we might change lists to go right-to-left, but that's not realistic. This outlook is in fact something that distinguishes hoon from haskell and many other languages and makes it more like C, where you know what your data structures look like on the inside, and you can use that information to stay grounded when reasoning about your programs. Instead of knowing the memory layout as in C, in hoon you know the nock layout of your data structures, and that is a Good Thing.

As for promoting binary functions, I agree in principle given the utility of `;:`. However, I think we should attempt to keep the standard library lean, which suggests that if we have a `++concat`, we don't really need `++weld` anymore. Instead of calling `:(weld [1 2]~ [3 4]~ [5 6]~)`, we could call `(concat [[1 2]~ [3 4]~ [5 6]~]~)`. I'd rather have the extra set of brackets in the `++concat` call than an entire extra function.

As for the `~(arm core sample)` syntax, I'm not convinced we should change it to `(arm~core sample)`. Almost every other language (with the possible exception of [haskell's lenses](https://hackage.haskell.org/package/lens), but who understands those other than Edward Kmett) has something equivalent to `arm:core~sample`. In C++, Java, or JavaScript, that would be `(new Class(arg)).method()`. This is not to say that we should use JavaScript as a shining beacon of language design, but I do think there's some convergent evolution going on here. It seems generally useful to be able to take a `|_` and just produce a core from it by supplying its arguments. Once you have a core, you can fire any of its arms. Another way to achieve this would be to have a `|_` compile to a "constructor" gate that you would slam (call) to obtain the core. That would look like `tap:(ls [1 2 3]~)`. A nice perk from that would be the ability to bunt a `|_`, which would be useful for "static methods," which are discussed a bit more below.

The main advantage of the `arm~core` syntax, though, is that it would produce a gate, so you could use it in all the places where you would want to use a gate, like this:
`(turn [(sy [1 2 ~]) (sy [3 4 5 ~])] tap~in)`
You could potentially also use it in `;~` chains. Maybe we could provide both syntaxes!

Most list-related arms would naturally be part of a door (`lent~ls`, `flop~ls`, `find~ls`, etc.), but some of them are more like "static methods:" arms that aren't centered on an "instance," or to put it more hooniciously, arms whose sample can't be factored to center around a single list: arms like `++gulf`, `++limo`, and arguably `++weld`, although `++weld` could be part of a door, in which case it would produce a gate with a single list as its argument. 

If there is a list core that contains most of the list arms, but we want some "static methods," one way is to have two cores: one `|_` and one |%`. That breaks the namespacing, however. Another way would be to add the "static" arms onto the `|_`, and just ignore the sample. Calling would look like this: `((gulf~ls ~) 1 10)`. It's a little ugly, so maybe we'd want to add the capability of bunting a `|_`. We can't do this right now because bunting evaluates the `$` arm, which doesn't exist in a `|_`.

Neither of these cases solves the problem of how we could cleanly call `++weld` repeatedly using `;:`. I'm not sure how big of a problem that is.