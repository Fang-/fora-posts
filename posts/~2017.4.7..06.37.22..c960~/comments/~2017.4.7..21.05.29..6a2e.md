## `~ridwex-midfel-hadmyr-radpub--danbep-locmun-dozter-marzod`
Doccords are definitely a good idea, and I'm pretty OK in being able to *any* name bindings, even in the middle of code. It seems a little bit overkill, though. (In Java doc comments or whatever, you are annotating the API for a function, which should be turned into docs. Hoon can do even *better* since it's purely functional, but then I don't really see the need for being able to formally define the internal pin `foo` is a `bar`...)

I'm definitely another one against `+=` being the arm for molds. I still occasionally mess up and type it instead of `+=`: `+|` is fine, though.

As I said in `:talk`, I kinda feel like I should be screaming re: `(list [a=@ b=@])`. The entire point of 151k Hoon was to remove context-specific parsing. Now Hoon does exactly what you type: Gate samples are `{a/@ b/@}` because you have to give it a type, and not `[a=@ b=@]` that magically is `$_` and bunted. This change is, possibly, even worse: You're introducing a new parsing context where *Hoon is fundamentally different*. At least before when you wrote `(list ,[a=@ b=@])` it was the same Hoon as anywhere else: here is a function, you call it with this value. It made sense (unlike gate samples), but it was just unwieldy. Now you're changing the value, and all tuples written, to mean a type where it shouldn't. You aren't calling a function with a tuple, but with *the type* of the tuple.

Right now, you can stick a `=+  a  (list {a/@ b/@})` in your code and use it like any other type, because it is. But with the change outlined, pulling types out of `+=` would mean that you have to change your syntax, removing spooky action from the constructor.

I'm not sure I even understand the reasoning behind this change. You want to differentiate between `(pair @ term)` being a value or a mold, but the beauty of Hoon's type system is that there *is* no difference. Types are just the range of values a gate can return.

I'm not sure I actually understand the reasoning behind `+=` either, tbh. When you decorate `++span` or something, you are marking the variants with `:<`. They are all applied from an AST walk, though, not tagged to the type system like old doccords, so I'm not sure why it matters that it's in the generator and not `*span` instead. Requesting `? span` would still end up at a twig that you can walk for comments, including being context-aware that you are entering a `$:` that is the result of the request.